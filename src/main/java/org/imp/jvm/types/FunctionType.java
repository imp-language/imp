package org.imp.jvm.types;

import org.apache.commons.collections4.map.LinkedMap;
import org.imp.jvm.legacy.ImpFile;
import org.imp.jvm.legacy.domain.Operator;
import org.imp.jvm.legacy.domain.scope.Identifier;
import org.imp.jvm.legacy.expression.Function;
import org.imp.jvm.legacy.expression.reference.VariableReference;
import org.imp.jvm.types.overloads.OperatorOverload;

import java.util.ArrayList;
import java.util.List;

public class FunctionType implements ImpType {

    public final String name;
    public final ImpFile parent;
    public final List<VariableReference> closures = new ArrayList<>();
    public final boolean isStatic;
    //    public final List<Function> signatures;
    private final LinkedMap<String, Function> signatures;

    public FunctionType(String name, ImpFile parent, boolean isStatic) {
        this.name = name;
        this.isStatic = isStatic;
        this.signatures = new LinkedMap<>();
        this.parent = parent;
    }

    /**
     * Add a Function to the Function type
     *
     * @param descriptor (Ljava/lang/Object;)I would take an object and return an int, for example.
     * @param signature  the function to add
     */
    public void addSignature(String descriptor, Function signature) {
        signatures.put(descriptor, signature);
        signature.functionType = this;
    }

    @Override
    public int getAddOpcode() {
        return 0;
    }

    @Override
    public Object getDefaultValue() {
        return null;
    }

    @Override
    public String getDescriptor() {
        return null;
    }

    @Override
    public int getDivideOpcode() {
        return 0;
    }

    @Override
    public String getInternalName() {
        return getName().replace(".", "/");
    }

    @Override
    public int getLoadVariableOpcode() {
        return 0;
    }

    @Override
    public int getMultiplyOpcode() {
        return 0;
    }

    @Override
    public String getName() {
        return this.parent.name + "/Function_" + name;
    }

    @Override
    public int getNegOpcode() {
        return 0;
    }

    @Override
    public OperatorOverload getOperatorOverload(Operator operator) {
        return null;
    }

    @Override
    public int getReturnOpcode() {
        return 0;
    }

    /**
     * @param descriptor generated by Function.getDescriptor(List<Identifier> identifiers)
     * @return Function if such an overload exists on this function type
     */
    public Function getSignature(String descriptor) {
        return signatures.get(descriptor);
    }

    public Function getSignature(List<ImpType> argumentTypes) {
        for (var function : signatures.values()) {
//            boolean returnTypesMatch = (function.returnType != returnType);
            boolean argTypesMatch = true;
            if (argumentTypes.size() != function.parameters.size()) {
                continue;
            }
            for (int i = 0; i < argumentTypes.size(); i++) {
                var parameterType = argumentTypes.get(i);
                var argumentType = function.parameters.get(i).type;
                if (!parameterType.equals(argumentType) && argumentType != BuiltInType.ANY) {
                    argTypesMatch = false;
                    break;
                }
            }
            boolean matchFound = argTypesMatch;
            if (matchFound) return function;
        }
        return null;
    }

    public Function getSignature(int pos) {
        return signatures.getValue(pos);
    }

    public Function getSignatureByTypes(List<ImpType> argTypes) {
        if (this.name.equals("log")) {
            if (argTypes.size() == 0) return this.signatures.get("");
            if (argTypes.get(0).equals(BuiltInType.VOID)) return null;
            return this.signatures.get("[Ljava/lang/Object;");
        }
        var identifiers = argTypes.stream().map(e -> new Identifier("_", e)).toList();
        return getSignature(argTypes);
    }

    public LinkedMap<String, Function> getSignatures() {
        return signatures;
    }

    @Override
    public int getStoreVariableOpcode() {
        return 0;
    }

    @Override
    public int getSubtractOpcode() {
        return 0;
    }

    @Override
    public Class<?> getTypeClass() {
        return null;
    }

    @Override
    public boolean isNumeric() {
        return false;
    }

    @Override
    public String kind() {
        return "function";
    }

    @Override
    public String toString() {

        String s = name + ", " + signatures.size() + " overloads";

        if (isStatic) {
            s += ", static";
        }
        return s;
    }
}
