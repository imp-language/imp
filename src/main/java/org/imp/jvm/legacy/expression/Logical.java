package org.imp.jvm.legacy.expression;

import org.imp.jvm.codegen.Logger;
import org.imp.jvm.legacy.domain.scope.Scope;
import org.imp.jvm.legacy.exception.Errors;
import org.imp.jvm.types.BuiltInType;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

public class Logical extends Expression {
    public final Expression left;
    public final Expression right;
    public final LogicalOperator logicalOperator;

    public enum LogicalOperator {
        AND,
        OR
    }

    public Logical(Expression left, Expression right, LogicalOperator logicalOperator) {
        this.left = left;
        this.right = right;
        this.logicalOperator = logicalOperator;
        this.type = left.type;
    }

    public void generate(MethodVisitor mv, Scope scope) {
        // Generated bytecode is slightly different between operators.

        if (logicalOperator == LogicalOperator.AND) {
            Label failureLabel = new Label(); // short-circuit evaluation, if left is false, skip remaining clauses and return "false"
            Label successLabel = new Label(); // both clauses are truthy, return "true"

            left.generate(mv, scope); // get the truthiness of the left expression
            mv.visitInsn(Opcodes.ICONST_1); // get "true" constant, actually "1"
            mv.visitJumpInsn(Opcodes.IF_ICMPNE, failureLabel); // if the left expression is false, skip to end

            right.generate(mv, scope); // get the truthiness of the right expression
            mv.visitInsn(Opcodes.ICONST_1); // get "true" constant, actually "1"
            mv.visitJumpInsn(Opcodes.IF_ICMPNE, failureLabel); // if the right expression is false, skip to end

            // if the right expression isn't false, here we store a success value of "1" and skip to the end
            mv.visitInsn(Opcodes.ICONST_1);
            mv.visitJumpInsn(Opcodes.GOTO, successLabel);

            mv.visitLabel(failureLabel);
            mv.visitInsn(Opcodes.ICONST_0);

            mv.visitLabel(successLabel);
        } else if (logicalOperator == LogicalOperator.OR) {

            Label failureLabel = new Label(); //
            Label successLabel = new Label(); // both clauses are truthy, return "true"
            Label endLabel = new Label();

            left.generate(mv, scope); // get the truthiness of the left expression
            mv.visitInsn(Opcodes.ICONST_1); // get "true" constant, actually "1"
            mv.visitJumpInsn(Opcodes.IF_ICMPEQ, successLabel); // if the left expression is true, skip to end

            right.generate(mv, scope); // get the truthiness of the right expression
            mv.visitInsn(Opcodes.ICONST_1); // get "true" constant, actually "1"
            mv.visitJumpInsn(Opcodes.IF_ICMPNE, failureLabel); // if the right expression is not true, skip to end

            mv.visitLabel(successLabel);
            mv.visitInsn(Opcodes.ICONST_1);
            mv.visitJumpInsn(Opcodes.GOTO, endLabel);

            mv.visitLabel(failureLabel);
            mv.visitInsn(Opcodes.ICONST_0);

            mv.visitLabel(endLabel);

        } else {
            Logger.syntaxError(Errors.ImplementationError, left);
        }

    }

    @Override
    public void validate(Scope scope) {
        left.validate(scope);
        right.validate(scope);

        if (left.type != BuiltInType.BOOLEAN) {
            Logger.syntaxError(Errors.LogicalOperationInvalidType, left, left.getCtx().getText());
        }
        if (right.type != BuiltInType.BOOLEAN) {
            Logger.syntaxError(Errors.LogicalOperationInvalidType, right, right.getCtx().getText());
        }
    }

}
