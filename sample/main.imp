// Variables
/*
log("Hello, World!")
val b = 4
mut c = 49
c = c + b
// b = b + 4 // mutability error
log(c)

// If/else
if b > 0 and true {
    log(b>0 and true)
} else {
    log(false)
}
*/

// Loops and lists (subject to change)
/*
log("for loop sum of range")
mut sum = 0
for i in range(0, 10) {
    sum = sum + i
}
log(sum)

log("for loop access through range")
val l = [0,1,3,2,4,5,6,7,8,9,10]
for i in range(0,11) {
    val v = at(l,i)
    log(v)
}
*/

// Union types (tagged unions)
/*
func testUnion(param int | float[] | int[]) {
    match param as id {
        int -> {
            log(id)
            log("int")
        }
        int[] -> {
            log(id)
            log("int[]")
        }
        // Comment this case out for a MatchCoverage error
        float[] -> {
            log(id)
            log("float[]")
        }
    }
}

testUnion(4)
testUnion([4,3,2,1])
testUnion([4.0])
// testUnion(4.0) // expect error
*/



struct Empty {}
struct Leaf {
	data int
}
type TreeNode = Tree | Empty
struct Tree {
    data int
    left TreeNode
    right TreeNode
}

func makeTree(value int) Tree {
    val left = Empty()
    val right = Empty()
    val tree = Tree(value, left, right)
    return tree
}

func insert(root Tree, value int) {
    if value < root.data {
        match root.left as a {
            Empty -> root.left = makeTree(value)
            Tree ->  insert(a, value)
        }
    } else {
        match root.right as a {
            Empty ->  root.right = makeTree(value)
            Tree -> insert(a, value)
        }
    }
}




/*
struct Generic[T] {
    key string
    t T
}

struct Name {
    first string
    last string
}


val name = Name("matt", "hall")
log(name)

val genericName = Generic("s", name)
val n = genericName.t
log(n)
log(n.first)

*/