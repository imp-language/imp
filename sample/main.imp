//struct Empty {}
//struct Leaf {
//	data int
//}
//
//type TreeNode = Tree | Empty
//struct Tree {
//    data int
//    left TreeNode
//    right TreeNode
//}
//
//func makeTree(root int) Tree {
//    val left = Tree(4, Empty(), Empty())
//    val right = Empty()
//    val tree = Tree(root, left, right)
//    log(left)
//    log(right)
//    log(tree)
//    return tree
//}
//val tree = makeTree(42)

struct Top {
    middle Middle
}

struct Middle {
    value Bottom
    other Bottom
    union string | int
}

struct Bottom {
    data int
}

//val b1 = Bottom(2)
//val b2 = Bottom(9)
//val mid = Middle(b1, b2)
val top = Top(Middle(Bottom(2), Bottom(9), 9))

//Todo(CURRENT): property access!
log(top)
log(top.middle)
log(top.middle.value)
log(top.middle.other)

val union = top.middle.union
log(union)

match union as reified {
    string -> {
        log("string")
    }
    int -> {
        log("int")
        log(4+reified)
    }
}

top.middle = Middle(Bottom(4),Bottom(5),6)
